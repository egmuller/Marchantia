# -*- coding: utf-8 -*-
"""
Created on Wed Feb 24 11:22:26 2021

@author: Valentin Laplaud

Useful generic functions 

"""


import numpy as np
import pandas as pd
import mpmath as mpm

import matplotlib.pyplot as plt
import seaborn

from scipy.spatial.distance import directed_hausdorff 

#  1. Loading text files from IJ

# A general function created to read txt files generated by imageJ, 
# and return a dataframe with the desired columns


def LoadImageJResults(FilePath,Columns):
   
        F = open(FilePath,'r') # Open file for reading
        lines = F.readlines() # Read all lines of the file

        Data = pd.DataFrame(data=None)
        
        for c in Columns:
            
            # find the column number in the text file header
            nC = lines[0].rstrip('\n').split('\t').index(c) 

            data = [] # temp data storage
        
            for l in lines[1:]:
                data = np.append(data,np.float(l.rstrip('\n').split('\t')[nC]))  
                # adds data from the file line by line
                # also removes '\n' from the last columns if present

            Data[c] = data # adding columns to dataframe
        
        return(Data) # return dataframe
    
#  2. Plotting boxplots with data points on top (from panda dataframe)

# A function combining panda.dataframe.plot with seaborn's swarmplot for a better display of data

def df2boxswarm(Data,columns,**kwargs):

    Title = None
    
    for key, value in kwargs.items(): 
        if key == 'suptitle':
            Title = value
        else:            
            print('Unknown key : ' + key+ '. Kwarg ignored.')
    
    Ld = len(Data)
    Lc = len(columns)
    
    xGrouping = np.concatenate(([0],np.concatenate(([np.ones(Ld)*x for x in range(1,Lc+1)]))))
    
    
    seaborn.swarmplot(x=xGrouping,
                      y=np.concatenate(([10],np.concatenate(([Data[c].to_np() for c in columns])))))  
    plt.xticks(ticks = list(range(1,Lc+1)), labels = columns)
    Data.boxplot(columns)                                    
    
    plt.xlim(0.5,Lc+0.5)
    fig = plt.gcf()
    fig.set_dpi(150)
    fig.suptitle(Title)

# 3. Coordinate conversion from cartesian to circular (in deg) an vice versa

def ToCirc(X,Y, **kwargs):
    
    Angle = 'rad'
    
    for key, value in kwargs.items(): 
        if key == 'angle':
            Angle = value
        else:            
            print('Unknown key : ' + key+ '. Kwarg ignored.')
    
    
    if Angle == 'deg':
        Alpha = np.rad2deg(np.arctan2(Y,X))
    elif Angle == 'rad':
        Alpha = np.arctan2(Y,X)
    else:
        print('Wrong angle unit : ' + Angle + '. Default to radians.')         
        Alpha = np.arctan2(Y,X)
        
    Radius = np.sqrt(np.square(X)+np.square(Y))
    
    return(Alpha,Radius)



def ToCart(Alpha,Radius, **kwargs):
    
    Angle = 'rad'
    
    for key, value in kwargs.items(): 
        if key == 'angle':
            Angle = value
        else:            
            print('Unknown key : ' + key + '. Kwarg ignored.')
    
    if Angle == 'deg':
        Alpharad = np.deg2rad(Alpha)
    elif Angle == 'rad':
        Alpharad = Alpha
    else:
        print('Wrong angle unit : ' + Angle + '. Default to radians.') 
        Alpharad = Alpha
    
    
    X = Radius*np.cos(Alpharad)
    Y = Radius*np.sin(Alpharad)
    
    return(X,Y)

# 4.1 Euclidian distance between two arrays of points in carthesian coordinates 
def dist(x1,y1,x2,y2):
    
    d = np.sqrt(np.square(x1-x2)+np.square(y1-y2))
    
    return(d)

# 4.2 Computation of Hausdorff distance (https://en.wikipedia.org/wiki/Hausdorff_distance) between two contours
    
    
def HausdorffDist(x1,y1,x2,y2, **kwargs):
    
    DebugPlots = False

    for key, value in kwargs.items():
        if key == 'debug':
            DebugPlots = value
    
    c1 = [[x,y] for x,y in zip(x1,y1)]
    c2 = [[x,y] for x,y in zip(x2,y2)]
    
    d1, i11, i12 = directed_hausdorff(c1, c2)
    d2, i21, i22 = directed_hausdorff(c2, c1)
    D = max(d1,d2)
    
    
    if DebugPlots:   
        f0, ax0 = plt.subplots(dpi=200,facecolor='white')
        ax0.set_aspect('equal', adjustable='box')
        ax0.plot(x1,y1,'r.')
        ax0.plot(x2,y2,'b.')
        ax0.plot(x1[i11],y1[i11],'*g')
        ax0.plot(x2[i12],y2[i12],'*g')
        ax0.plot([x1[i11],x2[i12]],[y1[i11],y2[i12]],'g')
        ax0.plot(x1[i21],y1[i21],'*c')
        ax0.plot(x2[i22],y2[i22],'*c')
        ax0.plot([x1[i21],x2[i22]],[y1[i21],y2[i22]],'c')
         
   
    return(D)

# 5. Intersection volume between sphere and cylinder

def interVolSC(Rs,Rc,Dsc):
    
                
    """ ref : Boersma and Kamminga, 1961. (https://core.ac.uk/download/pdf/82412251.pdf) """
    """ Equation (5) and (8) are implemented with the use of mpmath for computation of the elliptic integrals. """
    
    # Rs sphere radius, Rc cylinder radius, Dsc distance between the two centers
    
    # normalization to sphere radius
    rho = Rc/Rs
    eta = Dsc/Rs
    
    """ Formula is valid if sphere and cylinder intersects """
    if not (eta-rho) < 1:
        raise ValueError('Invalid case ! This code''s formula is only valid for intersecting sphere and cylinders \n -> (Dsc/Rs) - (Rc/Rs) < 1 !!')
        

    """ Heuman's lambda function """
    def Lambda0(beta,m):      
        """ From (https://link.springer.com/content/pdf/10.1007%2F978-3-642-65138-0.pdf) form 150.3 page 36 """
        L = 2/np.pi*(mpm.ellipe(m)*mpm.ellipf(beta,(1-m))+mpm.ellipk(m)*mpm.ellipe(beta,(1-m))-mpm.ellipk(m)*mpm.ellipf(beta,(1-m)))
        return(L)   
    
    
    if (eta+rho)>1 :
        """ Formula (5) is valid for eta+rho > 1 , this means that the part of the cylinder is outside the drop  """ 
        
        m = (1-(eta-rho)**2)/(4*rho*eta) # parameter for eliptic functions of mpmath (=k² in the paper)    
        theta = np.arcsin(eta-rho)  
        
        V = (2/3*np.pi*(1-Lambda0(theta,m)) 
             -8/9*np.sqrt(rho*eta)*(6*rho**2+2*rho*eta-3)*(1-m)*mpm.ellipk(m) 
             +8/9*np.sqrt(rho*eta)*(7*rho**2+eta**2-4)*mpm.ellipe(m))
    
    else:
        """ Formula (8) is valid for eta+rho <= 1 , this means that the cylinder is completely inside the drop  """ 
        
        m = (4*rho*eta)/(1-(eta-rho)**2) # parameter for eliptic functions of mpmath (=k² in the paper)    
        theta = np.arcsin((eta-rho)/(eta+rho))  
        
        V = (2/3*np.pi*(1-Lambda0(theta,m))
             -(4*np.sqrt(1-(eta-rho)**2))/(9*(eta+rho))*(2*rho-4*eta+(eta+rho)*(eta-rho)**2)*(1-m)*mpm.ellipk(m)
             +4/9*np.sqrt(1-(eta-rho)**2)*(7*rho**2+eta**2-4)*mpm.ellipe(m))

    
    return(float(V*Rs**3))

# 6. simple ismember function, checks if A is within B
def ismember(A, B):
    return [ np.sum(b == A) for b in B ]

# 7. R2 computation for a fit
def computeR2(Ydata,Yfit):
    # Ydata are the fitted data, Yfit the comuted value from the fit
    
    SumResidues = np.sum(np.square(np.subtract(Ydata,Yfit)))
    TotalVariance = np.sum(np.square(np.subtract(Ydata,np.mean(Ydata))))
    
    R2 = 1 - SumResidues/TotalVariance
    
    return R2
    